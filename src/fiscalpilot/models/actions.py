"""
Action models — proposed actions, approval workflow, execution results.

v0.4: FiscalPilot doesn't just analyze — it acts. These models represent
the full lifecycle of an executable action:

  Finding → ProposedAction → Approval → Execution → Result
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any

from pydantic import BaseModel, Field


class ActionStatus(str, Enum):
    """Lifecycle state of a proposed action."""

    PROPOSED = "proposed"        # Generated by analysis — awaiting review
    APPROVED = "approved"        # Human approved — ready to execute
    REJECTED = "rejected"        # Human rejected — will not execute
    EXECUTING = "executing"      # Currently running
    COMPLETED = "completed"      # Executed successfully
    FAILED = "failed"            # Execution attempted but failed
    ROLLED_BACK = "rolled_back"  # Completed then reversed


class ApprovalLevel(str, Enum):
    """Tiered autonomy — controls how much approval is needed.

    GREEN:    Low risk — auto-execute (categorize, tag, generate report)
    YELLOW:   Medium risk — execute then notify (send reminder, bulk categorize)
    RED:      High risk — require explicit approval (cancel subscription, pay invoice)
    CRITICAL: Very high risk — require multi-party approval (payroll, tax filing)
    """

    GREEN = "green"
    YELLOW = "yellow"
    RED = "red"
    CRITICAL = "critical"


class ActionType(str, Enum):
    """Categories of executable actions."""

    # Green (auto-execute)
    CATEGORIZE_TRANSACTION = "categorize_transaction"
    TAG_EXPENSE = "tag_expense"
    GENERATE_REPORT = "generate_report"

    # Yellow (execute + notify)
    SEND_REMINDER = "send_reminder"
    UPDATE_CATEGORY_BULK = "update_category_bulk"
    FLAG_FOR_REVIEW = "flag_for_review"

    # Red (require approval)
    CANCEL_SUBSCRIPTION = "cancel_subscription"
    PAY_INVOICE = "pay_invoice"
    RENEGOTIATE_VENDOR = "renegotiate_vendor"
    CREATE_BUDGET_ALERT = "create_budget_alert"

    # Critical (multi-party approval)
    CHANGE_PAYROLL = "change_payroll"
    MODIFY_TAX_FILING = "modify_tax_filing"
    TRANSFER_FUNDS = "transfer_funds"

    # Generic
    CUSTOM = "custom"


# Default mapping from action type to approval level
DEFAULT_APPROVAL_MAP: dict[ActionType, ApprovalLevel] = {
    ActionType.CATEGORIZE_TRANSACTION: ApprovalLevel.GREEN,
    ActionType.TAG_EXPENSE: ApprovalLevel.GREEN,
    ActionType.GENERATE_REPORT: ApprovalLevel.GREEN,
    ActionType.SEND_REMINDER: ApprovalLevel.YELLOW,
    ActionType.UPDATE_CATEGORY_BULK: ApprovalLevel.YELLOW,
    ActionType.FLAG_FOR_REVIEW: ApprovalLevel.YELLOW,
    ActionType.CANCEL_SUBSCRIPTION: ApprovalLevel.RED,
    ActionType.PAY_INVOICE: ApprovalLevel.RED,
    ActionType.RENEGOTIATE_VENDOR: ApprovalLevel.RED,
    ActionType.CREATE_BUDGET_ALERT: ApprovalLevel.RED,
    ActionType.CHANGE_PAYROLL: ApprovalLevel.CRITICAL,
    ActionType.MODIFY_TAX_FILING: ApprovalLevel.CRITICAL,
    ActionType.TRANSFER_FUNDS: ApprovalLevel.CRITICAL,
    ActionType.CUSTOM: ApprovalLevel.RED,
}


class ActionStep(BaseModel):
    """A single step within a proposed action."""

    order: int = Field(description="Step sequence number")
    description: str = Field(description="What this step does")
    reversible: bool = Field(default=False, description="Whether this step can be undone")


class ProposedAction(BaseModel):
    """An executable action proposed by the analysis pipeline.

    Each action is:
    - Tied to one or more findings
    - Dollar-quantified (estimated_savings)
    - Assigned an approval level
    - Broken into specific steps
    - Trackable through its full lifecycle
    """

    id: str = Field(description="Unique action ID (e.g., act_a1b2c3)")
    title: str = Field(description="Human-readable action title")
    description: str = Field(description="Detailed explanation of what this action does")
    action_type: ActionType = Field(default=ActionType.CUSTOM)
    approval_level: ApprovalLevel = Field(default=ApprovalLevel.RED)
    status: ActionStatus = Field(default=ActionStatus.PROPOSED)

    # Impact
    estimated_savings: float = Field(default=0.0, ge=0.0, description="Estimated annual savings")
    confidence: float = Field(default=0.7, ge=0.0, le=1.0)

    # Execution details
    steps: list[ActionStep] = Field(default_factory=list)
    target_system: str = Field(default="", description="System the action targets (e.g., 'quickbooks', 'xero')")
    executor: str = Field(default="", description="Executor class name to handle this action")
    parameters: dict[str, Any] = Field(default_factory=dict, description="Executor-specific parameters")

    # Provenance
    finding_ids: list[str] = Field(default_factory=list, description="Findings that led to this action")

    # Audit trail
    proposed_at: datetime = Field(default_factory=datetime.utcnow)
    approved_at: datetime | None = Field(default=None)
    approved_by: str | None = Field(default=None)
    executed_at: datetime | None = Field(default=None)
    completed_at: datetime | None = Field(default=None)

    metadata: dict[str, Any] = Field(default_factory=dict)

    @property
    def is_actionable(self) -> bool:
        """Whether this action can currently be executed."""
        return self.status == ActionStatus.APPROVED

    @property
    def is_terminal(self) -> bool:
        """Whether this action is in a final state."""
        return self.status in (
            ActionStatus.COMPLETED,
            ActionStatus.FAILED,
            ActionStatus.REJECTED,
            ActionStatus.ROLLED_BACK,
        )


class ExecutionResult(BaseModel):
    """Result of executing a single action."""

    action_id: str
    status: ActionStatus
    summary: str = Field(default="", description="Human-readable result summary")
    details: dict[str, Any] = Field(default_factory=dict)
    error: str | None = Field(default=None)
    started_at: datetime = Field(default_factory=datetime.utcnow)
    finished_at: datetime | None = Field(default=None)
    dry_run: bool = Field(default=False, description="Whether this was a dry-run (no side effects)")
    rollback_available: bool = Field(default=False)

    @property
    def succeeded(self) -> bool:
        return self.status == ActionStatus.COMPLETED


class ApprovalRule(BaseModel):
    """A rule that determines who can approve actions at a given level."""

    level: ApprovalLevel
    approver_emails: list[str] = Field(default_factory=list)
    require_all: bool = Field(
        default=False,
        description="If True, all approvers must approve (multi-party). If False, any one approver suffices.",
    )
    timeout_hours: float = Field(
        default=48.0,
        description="Auto-reject if not approved within this window.",
    )


class ApprovalDecision(BaseModel):
    """A record of an approval or rejection decision."""

    action_id: str
    decision: str = Field(description="approved or rejected")
    decided_by: str = Field(default="", description="Email or username of the approver")
    decided_at: datetime = Field(default_factory=datetime.utcnow)
    reason: str = Field(default="")
    modifications: dict[str, Any] = Field(
        default_factory=dict,
        description="Any modifications the approver made to the action before approving.",
    )
